generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [postgis]
}

// --- ENUMS ---

enum UserRole {
  READER // Simple lecteur / Utilisateur connecté
  AUTHOR // Auteur de travaux (ex: Professeur, Doctorant)
  LIBRARIAN // Bibliothécaire (Gestion des prêts, catalogue)
  ADMIN // Administrateur système
}

enum FileType {
  COVER_IMAGE
  DOCUMENT_PDF
  GEOJSON
  GEOJSON_DATA
  AVATAR
}

// NOUVEAU : Types de documents académiques
enum BookType {
  TFC // Travail de Fin de Cycle
  MEMOIRE // Mémoire de Master / DEA
  THESE // Thèse de Doctorat
  ARTICLE // Article Scientifique
  OUVRAGE // Livre / Manuel
  RAPPORT // Rapport de stage
  AUTRE
}

enum GeometryType {
  POINT // Ex: Station météo, Site de forage
  POLYGON // Ex: Commune, Campus, Parcelle
  LINESTRING // Ex: Route, Rivière, Faille
  MULTIPOLYGON // Ex: Archipel, Zone discontinue
  MULTILINESTRING // Ex: Réseau routier complexe
}

// --- UTILISATEURS & AUTHENTIFICATION (LUCIA) ---

model User {
  id           String    @id @default(cuid())
  email        String    @unique
  passwordHash String // Mot de passe haché (Argon2)
  name         String
  username     String    @unique
  avatarId     String?
  avatar       File?     @relation("UserAvatar", fields: [avatarId], references: [id])
  avatarUrl    String?
  bio          String?   @db.Text
  dateOfBirth  DateTime?
  role         UserRole  @default(READER)
  isSuspended  Boolean   @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations Lucia Auth
  sessions Session[]
  keys     Key[]

  // Relations Métier
  loans         Loan[]
  payments      Payment[]
  subscription  Subscription?
  authorProfile AuthorProfile?

  loanRequests LoanRequest[]

  subscriptionRequests SubscriptionRequest[]
}

model Session {
  id        String   @id @map("id")
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  ipAddress String?
  userAgent String?
  location  String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model Key {
  id          String  @id
  userId      String  @map("user_id")
  hashedValue String? @map("hashed_value")

  user User @relation(fields: [userId], references: [id])

  @@map("key")
}

model AuthorProfile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  biography   String    @db.Text
  dateOfDeath DateTime?

  books Book[]
}

// NOUVEAU MODÈLE : Faculté (Faculty)
model Faculty {
  id          String       @id @default(cuid())
  name        String       @unique
  description String?
  departments Department[] // Relation 1:N vers Department
}

// MODÈLE MIS À JOUR : Département (Department)
model Department {
  id          String  @id @default(cuid())
  name        String  @unique
  description String?

  // Nouvelle clé étrangère pour la relation avec la Faculté
  facultyId String?
  faculty   Faculty? @relation(fields: [facultyId], references: [id])

  books Book[]
}

model AcademicYear {
  id        String   @id @default(cuid())
  year      String   @unique
  startDate DateTime
  endDate   DateTime
  books     Book[]
}

model Book {
  id          String @id @default(cuid())
  title       String
  description String @db.Text

  // NOUVEAU : Le type de document
  type BookType @default(TFC)

  location  String?
  available Boolean   @default(true)
  postedAt  DateTime  @default(now())
  createdAt DateTime  @default(now())
  updatedAt DateTime?

  // Clés étrangères
  authorId String?
  author   AuthorProfile? @relation(fields: [authorId], references: [id])

  departmentId String?
  department   Department? @relation(fields: [departmentId], references: [id])

  academicYearId String?
  academicYear   AcademicYear? @relation(fields: [academicYearId], references: [id])

  // Fichiers associés
  coverImageId String?
  coverImage   File?   @relation("BookCover", fields: [coverImageId], references: [id])

  documentFileId String?
  documentFile   File?   @relation("BookDocument", fields: [documentFileId], references: [id])

  // Relations
  loans      Loan[]
  studyAreas BookStudyArea[]

  loanRequests LoanRequest[]
}

// --- GÉOSPATIAL (CŒUR DE GEOLIB) ---

model StudyArea {
  id          String  @id @default(cuid())
  name        String
  description String?

  geometryType GeometryType @default(POLYGON)
  centerLat    Float?
  centerLng    Float?

  // PostGIS geometry field for spatial data
  geometry Unsupported("geometry(Geometry, 4326)")?

  geojsonFileId String
  geojsonFile   File   @relation(fields: [geojsonFileId], references: [id])

  books BookStudyArea[]
  createdAt DateTime @default(now())
}

model BookStudyArea {
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  studyAreaId String
  studyArea   StudyArea @relation(fields: [studyAreaId], references: [id], onDelete: Cascade)

  @@id([bookId, studyAreaId])
}

// --- GESTION DES FICHIERS ---

model File {
  id        String   @id @default(cuid())
  url       String
  name      String
  mimeType  String
  size      Int
  type      FileType
  createdAt DateTime @default(now())

  bookCovers    Book[]      @relation("BookCover")
  bookDocuments Book[]      @relation("BookDocument")
  studyAreas    StudyArea[]
  userAvatars   User[]      @relation("UserAvatar") // Relation inverse ajoutée
  isDeleted Boolean @default(false) // Soft delete flag
}

// --- PRÊTS & FINANCE ---

model LoanRequest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  status    RequestStatus @default(PENDING)

  userId    String
  user      User     @relation(fields: [userId], references: [id])

  bookId    String
  book      Book     @relation(fields: [bookId], references: [id])

  @@unique([userId, bookId]) // Un utilisateur ne peut faire qu'une demande par livre à la fois
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum SubscriptionType {
  DAILY
  WEEKLY
  MONTHLY
  SEMESTER
  YEARLY
}

model Loan {
  id         String    @id @default(cuid())
  loanDate   DateTime  @default(now())
  dueDate    DateTime
  returnDate DateTime?
  isOverdue  Boolean   @default(false)

  userId String
  user   User   @relation(fields: [userId], references: [id])

  bookId   String?
  book     Book?     @relation(fields: [bookId], references: [id], onDelete: SetNull)
  payments Payment[]
}

model Subscription {
  id        String   @id @default(cuid())
  startDate DateTime @default(now())
  endDate   DateTime
  isActive  Boolean  @default(true)
  remainingDaysAtSuspension Int?
  type      SubscriptionType @default(MONTHLY)

  userId String @unique
  user   User   @relation(fields: [userId], references: [id])
}

model Payment {
  id          String   @id @default(cuid())
  amount      Decimal  @db.Decimal(10, 2)
  reason      String
  paymentDate DateTime @default(now())
  loanId      String?
  loan        Loan?    @relation(fields: [loanId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])
}

model SubscriptionRequest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  status    RequestStatus @default(PENDING)

  userId    String
  user      User     @relation(fields: [userId], references: [id])

  type      SubscriptionType @default(MONTHLY)
  isUpdate  Boolean  @default(false)

  @@unique([userId]) // Un utilisateur ne peut faire qu'une demande à la fois
}
